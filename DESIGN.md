# Design thinking

I have determined to use WebSockets, rather than gRPC, since I do not find it palatable for browser-based-client communications with the blackened service layer. At least not yet (pending proper support of HTTP/2).
However, I do like the notion of shared types between client and server. I'd like to utilize Zod for this.

I wish to keep the application simple, but still demonstrate my level of expertise. Here are my proposals:

Structure & Tooling:

- Monorepo structure using yarn workspaces (yarn via corepack).
- Separated API and static asset servers, with the static assets being the SPA.
- Docker containers for API, APP server, and Database
- Both in TS
- Use of Zod for validation of communications.
- Prisma as the ORM. This is more for demonstration purposes than actual need
  for such a small project.

## Architecture

- The Database will use an event-driven architecture for moves, which will be aggregated to provide the game state.
- Users log in via passkey.
  - If first-time login, generate a new user account
  - Users have:
    - a server-assigned uuid (PK)
    - friendly name (Auto-generate initially, allow user to change.) (UNIQUE)
- The Game has:
  - auto-id
  - a string ID generated by random-word-slugs (UNIQUE)
  - playerX (FK: userID)
  - playerO (FK: userID)
  - outcome: nullable char [NULL, X, O, C] where NULL is an unfinished game.
- Moves

  - auto-id
  - A gameID
  - move (chess move desigation, e.g. "XA1" for X in the upper-left or "OB3" for O in the right-middle)

- To recall a game board, we aggregate all moves to produce a board state.
- On recall, we will also validate the moves for permissibility. (if X moves twice in a row or some such nonsense, an error state is created and the offending game is deleted). This is to avoid potential cheating or error states. It shouldn't happen, but that doesn't mean it won't.
- The same function (isValidMove(board, nextMove)) is used when creating a new move.
- Outcome is just for convenience to avoid having to aggregate for completed games unless you want to view that specific board state.
- A user may view all their past games in a list (perhaps paginated?)
- Games-in-progress can be resumed
- By nature, games may be played live, or async.

## UI

- The home screen is a public leaderboard (top 10: [<user-friendly-name> | <win/loss score>]
- The navbar has a button to sign in, or (if signed in) go to the profile page.
- The profile page has your player friendly-name (edit button available), your win/loss count, a list of all your past games as links to view/resume (sorted by in progress, then by date last updated), and a "Create New Game" button.
- Game page ("/play/<friendly-slug>") has the game board and displays "YOUR TURN" or "X/Os TURN.
  - When it's your turn you can click a space and the move will be submitted.
